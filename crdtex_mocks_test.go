// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package crdtex

import (
	"context"
	"sync"
	"time"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
// 	func TestSomethingThatUsesInterface(t *testing.T) {
//
// 		// make and configure a mocked Interface
// 		mockedInterface := &InterfaceMock{
// 			InitConnFunc: func(addr string)  {
// 				panic("mock out the InitConn method")
// 			},
// 			StartFunc: func(ctx context.Context, finish chan<- struct{})  {
// 				panic("mock out the Start method")
// 			},
// 			UpdateRemoteFunc: func(ctx context.Context, addr string, state State) (State, error) {
// 				panic("mock out the UpdateRemote method")
// 			},
// 		}
//
// 		// use mockedInterface in code that requires Interface
// 		// and then make assertions.
//
// 	}
type InterfaceMock struct {
	// InitConnFunc mocks the InitConn method.
	InitConnFunc func(addr string)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, finish chan<- struct{})

	// UpdateRemoteFunc mocks the UpdateRemote method.
	UpdateRemoteFunc func(ctx context.Context, addr string, state State) (State, error)

	// calls tracks calls to the methods.
	calls struct {
		// InitConn holds details about calls to the InitConn method.
		InitConn []struct {
			// Addr is the addr argument value.
			Addr string
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Finish is the finish argument value.
			Finish chan<- struct{}
		}
		// UpdateRemote holds details about calls to the UpdateRemote method.
		UpdateRemote []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr string
			// State is the state argument value.
			State State
		}
	}
	lockInitConn     sync.RWMutex
	lockStart        sync.RWMutex
	lockUpdateRemote sync.RWMutex
}

// InitConn calls InitConnFunc.
func (mock *InterfaceMock) InitConn(addr string) {
	if mock.InitConnFunc == nil {
		panic("InterfaceMock.InitConnFunc: method is nil but Interface.InitConn was just called")
	}
	callInfo := struct {
		Addr string
	}{
		Addr: addr,
	}
	mock.lockInitConn.Lock()
	mock.calls.InitConn = append(mock.calls.InitConn, callInfo)
	mock.lockInitConn.Unlock()
	mock.InitConnFunc(addr)
}

// InitConnCalls gets all the calls that were made to InitConn.
// Check the length with:
//     len(mockedInterface.InitConnCalls())
func (mock *InterfaceMock) InitConnCalls() []struct {
	Addr string
} {
	var calls []struct {
		Addr string
	}
	mock.lockInitConn.RLock()
	calls = mock.calls.InitConn
	mock.lockInitConn.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *InterfaceMock) Start(ctx context.Context, finish chan<- struct{}) {
	if mock.StartFunc == nil {
		panic("InterfaceMock.StartFunc: method is nil but Interface.Start was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Finish chan<- struct{}
	}{
		Ctx:    ctx,
		Finish: finish,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc(ctx, finish)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//     len(mockedInterface.StartCalls())
func (mock *InterfaceMock) StartCalls() []struct {
	Ctx    context.Context
	Finish chan<- struct{}
} {
	var calls []struct {
		Ctx    context.Context
		Finish chan<- struct{}
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// UpdateRemote calls UpdateRemoteFunc.
func (mock *InterfaceMock) UpdateRemote(ctx context.Context, addr string, state State) (State, error) {
	if mock.UpdateRemoteFunc == nil {
		panic("InterfaceMock.UpdateRemoteFunc: method is nil but Interface.UpdateRemote was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Addr  string
		State State
	}{
		Ctx:   ctx,
		Addr:  addr,
		State: state,
	}
	mock.lockUpdateRemote.Lock()
	mock.calls.UpdateRemote = append(mock.calls.UpdateRemote, callInfo)
	mock.lockUpdateRemote.Unlock()
	return mock.UpdateRemoteFunc(ctx, addr, state)
}

// UpdateRemoteCalls gets all the calls that were made to UpdateRemote.
// Check the length with:
//     len(mockedInterface.UpdateRemoteCalls())
func (mock *InterfaceMock) UpdateRemoteCalls() []struct {
	Ctx   context.Context
	Addr  string
	State State
} {
	var calls []struct {
		Ctx   context.Context
		Addr  string
		State State
	}
	mock.lockUpdateRemote.RLock()
	calls = mock.calls.UpdateRemote
	mock.lockUpdateRemote.RUnlock()
	return calls
}

// Ensure, that TimerMock does implement Timer.
// If this is not the case, regenerate this file with moq.
var _ Timer = &TimerMock{}

// TimerMock is a mock implementation of Timer.
//
// 	func TestSomethingThatUsesTimer(t *testing.T) {
//
// 		// make and configure a mocked Timer
// 		mockedTimer := &TimerMock{
// 			ChanFunc: func() <-chan time.Time {
// 				panic("mock out the Chan method")
// 			},
// 			ResetFunc: func(d time.Duration)  {
// 				panic("mock out the Reset method")
// 			},
// 			ResetAfterChanFunc: func(d time.Duration)  {
// 				panic("mock out the ResetAfterChan method")
// 			},
// 		}
//
// 		// use mockedTimer in code that requires Timer
// 		// and then make assertions.
//
// 	}
type TimerMock struct {
	// ChanFunc mocks the Chan method.
	ChanFunc func() <-chan time.Time

	// ResetFunc mocks the Reset method.
	ResetFunc func(d time.Duration)

	// ResetAfterChanFunc mocks the ResetAfterChan method.
	ResetAfterChanFunc func(d time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Chan holds details about calls to the Chan method.
		Chan []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
			// D is the d argument value.
			D time.Duration
		}
		// ResetAfterChan holds details about calls to the ResetAfterChan method.
		ResetAfterChan []struct {
			// D is the d argument value.
			D time.Duration
		}
	}
	lockChan           sync.RWMutex
	lockReset          sync.RWMutex
	lockResetAfterChan sync.RWMutex
}

// Chan calls ChanFunc.
func (mock *TimerMock) Chan() <-chan time.Time {
	if mock.ChanFunc == nil {
		panic("TimerMock.ChanFunc: method is nil but Timer.Chan was just called")
	}
	callInfo := struct {
	}{}
	mock.lockChan.Lock()
	mock.calls.Chan = append(mock.calls.Chan, callInfo)
	mock.lockChan.Unlock()
	return mock.ChanFunc()
}

// ChanCalls gets all the calls that were made to Chan.
// Check the length with:
//     len(mockedTimer.ChanCalls())
func (mock *TimerMock) ChanCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockChan.RLock()
	calls = mock.calls.Chan
	mock.lockChan.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *TimerMock) Reset(d time.Duration) {
	if mock.ResetFunc == nil {
		panic("TimerMock.ResetFunc: method is nil but Timer.Reset was just called")
	}
	callInfo := struct {
		D time.Duration
	}{
		D: d,
	}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc(d)
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//     len(mockedTimer.ResetCalls())
func (mock *TimerMock) ResetCalls() []struct {
	D time.Duration
} {
	var calls []struct {
		D time.Duration
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// ResetAfterChan calls ResetAfterChanFunc.
func (mock *TimerMock) ResetAfterChan(d time.Duration) {
	if mock.ResetAfterChanFunc == nil {
		panic("TimerMock.ResetAfterChanFunc: method is nil but Timer.ResetAfterChan was just called")
	}
	callInfo := struct {
		D time.Duration
	}{
		D: d,
	}
	mock.lockResetAfterChan.Lock()
	mock.calls.ResetAfterChan = append(mock.calls.ResetAfterChan, callInfo)
	mock.lockResetAfterChan.Unlock()
	mock.ResetAfterChanFunc(d)
}

// ResetAfterChanCalls gets all the calls that were made to ResetAfterChan.
// Check the length with:
//     len(mockedTimer.ResetAfterChanCalls())
func (mock *TimerMock) ResetAfterChanCalls() []struct {
	D time.Duration
} {
	var calls []struct {
		D time.Duration
	}
	mock.lockResetAfterChan.RLock()
	calls = mock.calls.ResetAfterChan
	mock.lockResetAfterChan.RUnlock()
	return calls
}
