// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package crdtex

import (
	"context"
	"sync"
)

// Ensure, that InterfaceMock does implement Interface.
// If this is not the case, regenerate this file with moq.
var _ Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of Interface.
//
// 	func TestSomethingThatUsesInterface(t *testing.T) {
//
// 		// make and configure a mocked Interface
// 		mockedInterface := &InterfaceMock{
// 			InitConnFunc: func(addr string)  {
// 				panic("mock out the InitConn method")
// 			},
// 			StartFunc: func(ctx context.Context, finish chan<- struct{})  {
// 				panic("mock out the Start method")
// 			},
// 			UpdateRemoteFunc: func(ctx context.Context, addr string, state State) (State, error) {
// 				panic("mock out the UpdateRemote method")
// 			},
// 		}
//
// 		// use mockedInterface in code that requires Interface
// 		// and then make assertions.
//
// 	}
type InterfaceMock struct {
	// InitConnFunc mocks the InitConn method.
	InitConnFunc func(addr string)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, finish chan<- struct{})

	// UpdateRemoteFunc mocks the UpdateRemote method.
	UpdateRemoteFunc func(ctx context.Context, addr string, state State) (State, error)

	// calls tracks calls to the methods.
	calls struct {
		// InitConn holds details about calls to the InitConn method.
		InitConn []struct {
			// Addr is the addr argument value.
			Addr string
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Finish is the finish argument value.
			Finish chan<- struct{}
		}
		// UpdateRemote holds details about calls to the UpdateRemote method.
		UpdateRemote []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr string
			// State is the state argument value.
			State State
		}
	}
	lockInitConn     sync.RWMutex
	lockStart        sync.RWMutex
	lockUpdateRemote sync.RWMutex
}

// InitConn calls InitConnFunc.
func (mock *InterfaceMock) InitConn(addr string) {
	if mock.InitConnFunc == nil {
		panic("InterfaceMock.InitConnFunc: method is nil but Interface.InitConn was just called")
	}
	callInfo := struct {
		Addr string
	}{
		Addr: addr,
	}
	mock.lockInitConn.Lock()
	mock.calls.InitConn = append(mock.calls.InitConn, callInfo)
	mock.lockInitConn.Unlock()
	mock.InitConnFunc(addr)
}

// InitConnCalls gets all the calls that were made to InitConn.
// Check the length with:
//     len(mockedInterface.InitConnCalls())
func (mock *InterfaceMock) InitConnCalls() []struct {
	Addr string
} {
	var calls []struct {
		Addr string
	}
	mock.lockInitConn.RLock()
	calls = mock.calls.InitConn
	mock.lockInitConn.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *InterfaceMock) Start(ctx context.Context, finish chan<- struct{}) {
	if mock.StartFunc == nil {
		panic("InterfaceMock.StartFunc: method is nil but Interface.Start was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Finish chan<- struct{}
	}{
		Ctx:    ctx,
		Finish: finish,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc(ctx, finish)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//     len(mockedInterface.StartCalls())
func (mock *InterfaceMock) StartCalls() []struct {
	Ctx    context.Context
	Finish chan<- struct{}
} {
	var calls []struct {
		Ctx    context.Context
		Finish chan<- struct{}
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// UpdateRemote calls UpdateRemoteFunc.
func (mock *InterfaceMock) UpdateRemote(ctx context.Context, addr string, state State) (State, error) {
	if mock.UpdateRemoteFunc == nil {
		panic("InterfaceMock.UpdateRemoteFunc: method is nil but Interface.UpdateRemote was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Addr  string
		State State
	}{
		Ctx:   ctx,
		Addr:  addr,
		State: state,
	}
	mock.lockUpdateRemote.Lock()
	mock.calls.UpdateRemote = append(mock.calls.UpdateRemote, callInfo)
	mock.lockUpdateRemote.Unlock()
	return mock.UpdateRemoteFunc(ctx, addr, state)
}

// UpdateRemoteCalls gets all the calls that were made to UpdateRemote.
// Check the length with:
//     len(mockedInterface.UpdateRemoteCalls())
func (mock *InterfaceMock) UpdateRemoteCalls() []struct {
	Ctx   context.Context
	Addr  string
	State State
} {
	var calls []struct {
		Ctx   context.Context
		Addr  string
		State State
	}
	mock.lockUpdateRemote.RLock()
	calls = mock.calls.UpdateRemote
	mock.lockUpdateRemote.RUnlock()
	return calls
}
